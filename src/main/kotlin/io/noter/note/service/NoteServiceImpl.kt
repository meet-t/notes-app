package io.noter.note.service

import io.noter.exception.DetailedRequestException
import io.noter.note.dto.NoteRequest
import io.noter.note.dto.NoteResponse
import io.noter.note.dto.NoteSummaryResponse
import io.noter.note.dto.PageDto
import io.noter.note.entity.Note
import io.noter.note.repo.NoteRepository
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import org.springframework.cache.annotation.CacheEvict
import org.springframework.cache.annotation.Cacheable
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Sort
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import java.time.Instant
import java.util.UUID

@Service
class NoteServiceImpl(
    private val noteRepository: NoteRepository
) : NoteService {

    private val log = LoggerFactory.getLogger(javaClass)

    @CacheEvict(value = ["latestNotes"], key = "#request.userId")
    override fun create(request: NoteRequest): NoteResponse {
        val note = Note(
            id  = null, // ID will be generated by the database
            userId = request.userId!!,
            title = request.title,
            content = request.content,
            expiresAt = request.expiresAt
        )
        return noteRepository.save(note).toDto()
    }

    @CacheEvict(value = ["latestNotes"], key = "#request.userId")
    override fun update(request: NoteRequest): NoteResponse {
        val existing = noteRepository.findByIdAndUserId(request.id!!, request.userId!!)
            ?: throw IllegalArgumentException("Note not found for id ${request.id} and user ${request.userId}")

        request.title.let { existing.title = it }
        request.content.let { existing.content = it }
        request.expiresAt.let { existing.expiresAt = it }

        return noteRepository.save(existing).toDto()
    }

    @Transactional
    @CacheEvict(value = ["latestNotes"], key = "#userId")
    override fun delete(userId: UUID, noteId: Long) {
        val note = noteRepository.findByIdAndUserId(noteId, userId)
            ?: throw IllegalArgumentException("Note not found for id $noteId and user $userId")
        noteRepository.delete(note)
    }

    override fun findByNoteIdAndUserId(userId: UUID, noteId: Long): NoteResponse {
        val note = noteRepository.findByIdAndUserId(noteId, userId)
            ?: throw DetailedRequestException(HttpStatus.NOT_FOUND,HttpStatus.NOT_FOUND.name,"Note not found for id $noteId and user $userId")

        if (note.expiresAt != null && note.expiresAt!!.isBefore(Instant.now())) {
            throw DetailedRequestException(HttpStatus.NOT_FOUND,HttpStatus.NOT_FOUND.name,"This note has expired!")
        }

        return note.toDto()
    }

    override fun findAllValidNotes(userId: UUID,pageable: Pageable): PageDto<NoteSummaryResponse> {
        val notesList =  noteRepository
            .findValidNotesByUserId(userId, Instant.now(),pageable)

        return PageDto(notesList)
    }

    @Cacheable(value = ["latestNotes"], key = "#userId")
    override fun findLatestByUserId(userId: UUID): List<NoteSummaryResponse> {
        val pageable = PageRequest.of(0, 1000, Sort.by(Sort.Direction.DESC, "createdOn"))
        val notesList =  noteRepository
            .findValidNotesByUserId(userId, Instant.now(),pageable)

        return notesList.content
    }


    private fun Note.toDto() = NoteResponse(
        id = id,
        title = title,
        content = content,
        createdOn = createdOn,
        updatedOn = updatedOn,
        expiresAt = expiresAt
    )
}