package io.noter.note.service

import io.noter.exception.DetailedRequestException
import io.noter.note.dto.NoteRequest
import io.noter.note.dto.NoteResponse
import io.noter.note.dto.NoteSummaryResponse
import io.noter.note.dto.PageDto
import io.noter.note.entity.Note
import io.noter.note.repo.NoteRepository
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import org.springframework.cache.annotation.CacheEvict
import org.springframework.cache.annotation.Cacheable
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Sort
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import java.time.Instant
import java.util.UUID

@Service
class NoteServiceImpl(
    private val noteRepository: NoteRepository
) : NoteService {

    private val log = LoggerFactory.getLogger(javaClass)

    @CacheEvict(value = ["latestNotes"], key = "#request.userId")
    override fun create(request: NoteRequest): NoteResponse {
        val note = Note(
            id  = null, // ID will be generated by the database
            userId = request.userId!!,
            title = request.title,
            content = request.content,
            expiresAt = request.expiresAt
        )
        val createdNote = noteRepository.save(note).toDto()
        log.info("Created noteId: ${createdNote.id}")
        return createdNote
    }

    @CacheEvict(value = ["latestNotes"], key = "#request.userId")
    override fun update(request: NoteRequest): NoteResponse {
        val existing = noteRepository.findByIdAndUserId(request.id!!, request.userId!!)
            ?: throw IllegalArgumentException("Note not found for id ${request.id} and user ${request.userId}")

        request.title.let { existing.title = it }
        request.content.let { existing.content = it }
        request.expiresAt.let { existing.expiresAt = it }
        val note = noteRepository.save(existing).toDto()
        log.info("Updated noteId: ${note.id}")
        return note
    }

    @Transactional
    @CacheEvict(value = ["latestNotes"], key = "#userId")
    override fun delete(userId: UUID, noteId: Long) {
        val note = noteRepository.findByIdAndUserId(noteId, userId)
            ?: throw IllegalArgumentException("Note not found for id $noteId and user $userId")
        noteRepository.delete(note)
        log.info("Deleted note $noteId for user $userId")
    }

    override fun findByNoteIdAndUserId(userId: UUID, noteId: Long): NoteResponse {
        log.info("findByNoteIdAndUserId: $noteId for user $userId")
        val note = noteRepository.findByIdAndUserId(noteId, userId)
            ?: throw DetailedRequestException(HttpStatus.NOT_FOUND,HttpStatus.NOT_FOUND.name,"Note not found for id $noteId and user $userId")

        if (note.expiresAt != null && note.expiresAt!!.isBefore(Instant.now())) {
            throw DetailedRequestException(HttpStatus.NOT_FOUND,HttpStatus.NOT_FOUND.name,"This note has expired!")
        }

        return note.toDto()
    }

    override fun findAllValidNotes(userId: UUID,pageable: Pageable): PageDto<NoteSummaryResponse> {
        log.info("findAllValidNotes user $userId")
        val notesList =  noteRepository
            .findValidNotesByUserId(userId, Instant.now(),pageable)

        return PageDto(notesList)
    }

    @Cacheable(value = ["latestNotes"], key = "#userId")
    override fun findLatestByUserId(userId: UUID): List<NoteSummaryResponse> {
        val pageable = PageRequest.of(0, 1000, Sort.by(Sort.Direction.DESC, "createdOn"))
        log.info("findLatestByUserId $userId")
        val notesList =  noteRepository
            .findValidNotesByUserId(userId, Instant.now(),pageable)

        return notesList.content
    }


    private fun Note.toDto() = NoteResponse(
        id = id,
        title = title,
        content = content,
        createdOn = createdOn,
        updatedOn = updatedOn,
        expiresAt = expiresAt
    )
}